
<!DOCTYPE html>
<html>
<head>
  <title>Node Packet</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="site/idl.css">
  <script src="http://code.jquery.com/jquery-1.5.2.js" type="text/javascript"></script>
  <script src="site/idl.js" type="text/javascript"></script>
</head>
<body>
  
  <a href="http://github.com/bigeasy/node-packet"><img style="position: fixed; top: 0; right:
  0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"
  alt="Fork me on GitHub" /></a>
  
  <div id="container">
    <div id="narrative">
      
        
          <h2 class="namespace"><a name=""></a></h2>
        
        
        
          <h1>Node Packet</h1>

<p>An evented binary packet and structure parser for Node.js.</p>
        
      
        
          <h2 class="namespace"><a name="Synopsis">Synopsis</a></h2>
        
        
        
          <p>Use tar as an example?</p>
        
      
        
          <h2 class="namespace"><a name="Objectives">Objectives</a></h2>
        
        
        
          <p>Node Packet simplifies the construction an maintainence of libraries that
convert binary to JavaScript and back. The name Packet may make you think that
it is desinged solely for binary network protocols, but it is also used to read
and write binary file formats.</p>

<p><strong>Incremental</strong> ~ Node packet creates incremental parsers and serailizers that
are almost as fast as the parser you'd write by hand, but a lot easier to define
and maintain.</p>

<p><strong>Declarative</strong> ~ Packet defines a binary structure using a pattern language
inspired by Perl's <code>pack</code>. The binary patterns can be used to define both
parsers and serializers. If you have a protocol specificationre, or even just a
C header file with structures that define your binary data, you can probably
transalte that directly into Node Packet patterns.</p>

<p>For parsers, you match the patterns to actions you want to take when the pattern
is matched. For serializers you simply give the values to write the pattern to
follow when writing them.</p>

<p><strong>Expressive</strong> ~ The pattern language can express</p>

<ul>
<li>signed and unsigned integers, </li>
<li>endianess of singed and unsigned integers,</li>
<li>floats and doubles,</li>
<li>fixed length arrays of characters or numbers,</li>
<li>length encoded strings of characters or numbers,</li>
<li>zero terminated strings of characters or numbers,</li>
<li>said strings terminated any fixed length terminator you specify,</li>
<li>padding of said strings with any padding value you specify,</li>
<li>singed and unsigned integers extracted from bit packed integers,</li>
<li>conditions based on bit patterns</li>
<li>character encodings,</li>
<li>custom tranformations,</li>
<li>and pipelines of character encodings and custom tranformations.</li>
</ul>

<p><strong>Streaming</strong> ~ Node Packet implements the Node.js <a href="http://nodejs.org/docs/v0.4.7/api/streams.html">stream
interface</a> in both the <code>Parser</code>
and the <code>Serializer</code>. You can pump a stream into a Packet <code>Parser</code> and it will
invoke your packet handlers.  </p>
        
      
        
          <h2 class="namespace"><a name="Installing">Installing</a></h2>
        
        
        
          <p>Install Packet using NPM. The source is available on
<a href="https://github.com/bigeasy/node-packet">GitHub</a>.</p>
        
          <div class='highlight'><pre>npm install packet</pre></div>
        
          
        
      
        
          <h2 class="namespace"><a name="Binary Pattern Language">Binary Pattern Language</a></h2>
        
        
        
          <p>Node Packet defines a binrary format using a binary pattern language inspried by
Perl's <code>pack</code> function. The pattern language is used in a <code>Parser</code> to define the
parameters passed to callback when enough bytes are read from the input stream
to satisfy the pattern. The pattern language is used in a <code>Serializer</code> to define
how JavaScript primitives passed to the <code>serialize</code> method are written to stream.</p>

<p>The pattern works with a <code>Parser</code> to deconstruct a binary stream and turn it
into JavaScript primitives, passing those primitives as the arguments to a user
defined callback.</p>

<h3>Big-Endian Byte Ordering</h3>

<p>To define a big-endian byte ordering for a field, prefix the bit size with <code>b</code>.
<strong>Mnemonic</strong>: The letter <code>b</code> stands for big-endian.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b16&quot;</span>             <span class="c1">// Big-endian 32 bit number.</span>
<span class="s2">&quot;b8&quot;</span>              <span class="c1">// Endianess of a single byte is irrelevant.</span>
<span class="s2">&quot;l16, b8&quot;</span>         <span class="c1">// Big-endian 16 bit integer followed by a byte.</span>
</pre></div>

        
          <h3>Little-Endian Byte Ordering</h3>

<p>To define a little-endian byte ordering for a field, prefix the bit size with <code>l</code>.
<strong>Mnemonic</strong>: The letter <code>l</code> stands for little-endian.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l32&quot;</span>             <span class="c1">// Little-endian 32 bit integer.</span>
<span class="s2">&quot;l8&quot;</span>              <span class="c1">// Endianess of a single byte is irrelevant.</span>
<span class="s2">&quot;l16, b8&quot;</span>         <span class="c1">// Little endian 16 bit integer followed by a byte.</span>
</pre></div>

        
          <h3>Skipping Bytes</h3>

<p>You can skip over bytes your pattern with <code>x</code>. <strong>Mnemonic</strong>: The letter <code>x</code>
means to cross-out, which is kind of like skipping.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b8, x16, l16&quot;</span>    <span class="c1">// A byte separated from a little-endian 16 bit integer by 16</span>
                  <span class="c1">// two bytes.</span>
</pre></div>

        
          <h3>Signed Versus Unsigned Integers</h3>

<p>All numbers are assumed to be unsigned, unless prefixed by a negative symbol.
<strong>Mnemonic</strong>: The <code>-</code> symbol indicates the possiblity of negative numbers.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;-b32&quot;</span>            <span class="c1">// Big-endian 32 bit signed integer.</span>
<span class="s2">&quot;-l32&quot;</span>            <span class="c1">// Little-endian 32 bit signed integer.</span>
<span class="s2">&quot;b32&quot;</span>             <span class="c1">// Big-endian 32 bit unsigned integer.</span>
</pre></div>

        
          <h3>IEEE 754 Floating Point Numbers</h3>

<p>The number type for JavaScript is the  64 bit IEEE 754 floating point. Node
Packet can read write 64 bit and 32 bit IEEE 754 floating point numbers.</p>

<p>To indicated that the type is a floating point number, use the <code>f</code> type suffix.
This is indicated with a <code>f</code> suffix.  <strong>Mnemonic</strong>: The letter <code>f</code> stands for
<em>floating-point</em>.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b64f&quot;</span>            <span class="c1">// Big-endian 64 bit IEEE 754 double floating point number.</span>
<span class="s2">&quot;l32f&quot;</span>            <span class="c1">// Little-endian 32 bit IEEE 754 single floating point number.</span>
</pre></div>

        
          <p>The floating-point numbers can be stored in little-endian or big-endian byte order.</p>

<h3>Arrays of Raw Bytes</h3>

<p>A value will be converted to a big-endian array of bytes if followed by an <code>a</code>
suffix. <strong>Mnemonic</strong>: The letter <code>a</code> stands for <em>array</em>.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128a&quot;</span>           <span class="c1">// Unsigned little-endian 128 bit integer as big-endian array</span>
                  <span class="c1">// of bytes.</span>
</pre></div>

        
          <p>Note that big-endian means that the most signifcant byte is at index <code>0</code> of the
array.</p>

<p>This can be surprising if you're expecting the the significance of the bytes
will increase with the index of the array, but then that's what little-endian is
all about. (Big-endian orders like Arabic numerals, while little-endian orders
like offsets into memory.)</p>

<p>If you'd prefer a little-endian array, you can reverse the array with the <code>@</code>
qualifier. <strong>Mnemonic</strong>: The <code>@</code> character is a swirl and we want to turn our
array around.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128a@&quot;</span>          <span class="c1">// Unsigned little-endian 128 bit integer as little-endian</span>
                  <span class="c1">// array of bytes.</span>
</pre></div>

        
          <h3>Bytes as Hex Strings</h3>

<p>A value will be converted to a big-endian hex string if followed by an <code>h</code>
suffix. </p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128h&quot;</span>           <span class="c1">// Unsigned little-endian 128 bit integer as a big-endian hex</span>
                  <span class="c1">// string.</span>
</pre></div>

        
          <p>Like the raw byte of arrays, the hex string is in big-endian order with the most 
significant bytes at the top. It is less likely that you'll want to reverse a
hex string, but if you, you can use the <code>@</code> qualifier. <strong>Mnemonic</strong>: The <code>@</code>
character is a swirl and we want to turn our string  around.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128h@&quot;</span>          <span class="c1">// Unsigned little-endian 128 bit integer as a little-endian</span>
                  <span class="c1">// hex string.</span>
</pre></div>

        
          <h3>Arrays of Common Types</h3>

<p>It is often the case that a binary format contains an array of values. The most
common case are arrays of bytes represnting ASCII or UTF-8 strings.</p>

<p>Arrays are specified with an subscript and a count. <strong>Menmonic</strong>: The square
brackets are used as array subscripts in JavaScript, and used to declare array
length in other C dialect languages.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b32[4]&quot;</span>          <span class="c1">// An array of four big-endian 32 bit numbers.</span>
<span class="s2">&quot;b8[16]&quot;</span>          <span class="c1">// An array of 16 bytes.</span>
</pre></div>

        
          <p>The array notation produces an array of the type before the subscript.</p>

<h3>Length Encoded Arrays</h3>

<p>Length encoded arrays are specified by joining a count type and a value type
with a <code>/</code>. <strong>Mnemonic</strong>: Inspired by Perl's <code>pack</code>, this count and type
separator character is as good as any.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b8/b8&quot;</span>           <span class="c1">// Length encoded byte array with a byte length.</span>
<span class="s2">&quot;l16/b8&quot;</span>          <span class="c1">// Length encoded byte array with 16 bit little-endian length.</span>
</pre></div>

        
          <h3>Zero Terminated Arrays</h3>

<p>Zero terminated series are speified with a <code>z</code> qualifier. <strong>Mnemonic</strong>: The
letter <code>z</code> stands for zero.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l16z&quot;</span>            <span class="c1">// Little-endian 16 bit numbers terminated by a zero value.</span>
<span class="s2">&quot;b8z&quot;</span>             <span class="c1">// Byte string terminated by zero.</span>
</pre></div>

        
          <h3>Transforms</h3>

<p>Often there are transformations that you need to perform on an field to get
it to its final state. You may need to convert a byte array to string of a
particular character encoding, for example. This is done with a tranformation
functions which are specified with a transformation pipeline.</p>

<p>If the transformation is a fixed transformation, you can perform the
transformation by defining a pipeline. A pipeline defines one or more
tranformations that are invoked on the value after parsing and before
serialization. The transformations can accept scalar JavaScript parameters.</p>
        
          <div class="highlight"><pre><span class="kd">function</span> <span class="nx">str</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">parsing</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">parsing</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">buffer</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">length</span> <span class="o">+=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">reutrn</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">value</span> <span class="o">+=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

        
          <p>Now you can use the transform in your pattern.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;n8z|str(&#39;ascii&#39;)&quot;</span>      <span class="c1">// An ascii string terminated by zero.</span>
<span class="s2">&quot;n8z|str(&#39;ascii&#39;), b16&quot;</span> <span class="c1">// An ascii string terminated by zero followed by a</span>
                        <span class="c1">// big-endian 16 bit integer.</span>
</pre></div>

        
          <p>The <code>str</code> transform is defined by default. The transform names are purposely
terse to fit with the brevity of the pattern language.</p>
        
      
        
          <h2 class="namespace"><a name="Reference">Reference</a></h2>
        
        
        
          
        
      
        
          <h3 class="namespace"><a name="packet">packet</a></h3>
        
        
        
          <p>Node Packet exports the ec2 namespace, which provides the {{Structure}},
{{Parser}} and {{Serializer}} classes.</p>
        
      
        
          <h3 class="class"><a name="Structure">packet.Structure()</a></h3>
        
        
            
        
        
          <p>The packet pattern.</p>

<p>A structure is an object that both reads from and writes to a buffer
syncrhonously. When reading, buffer must contain the entire contents of the
structure. When writing, the buffer must have enough space to accomdoate the
structure.</p>
        
      
        
          
            <h3 class="function"><a name="read_buffer_offset_callback">read(buffer,  [offset], callback)</a></h3>
          
        
        
            
                <div class="parameter">
                  <h4>buffer</h4>
                  
                    <p>The byte buffer.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>offset</h4>
                  
                    <p>The optional offset into the byte buffer. Defaults to <code>0</code>.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>callback</h4>
                  
                    <p>Called with the parameters read from the byte buffer.</p>
                  
                </div>
            
        
        
          <p>The read method accepts a buffer with an optional offset. The number of
arguments is determined by the structure packet pattern, and must match
the number of arguments expected by the packet pattern.</p>

<p>The callback will be called with the fields read from the buffer, with the
actual count of bytes read as the last parameter.</p>
        
      
        
          
            <h3 class="function"><a name="write_buffer_offset_value">write(buffer,  [offset],  value...)</a></h3>
          
        
        
            
                <div class="parameter">
                  <h4>buffer</h4>
                  
                    <p>The byte buffer.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>offset</h4>
                  
                    <p>The optional offset into the byte buffer. Defaults to <code>0</code>.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>value</h4>
                  
                    <p>The values of the structure.</p>
                  
                </div>
            
        
        
          <p>Write the arguments to the  buffer at the optional offset. The arguments are
determined by the structure bit pattern. Returns the number of bytes written.</p>
        
      
        
          
            <h3 class="function"><a name="sizeOf_value">sizeOf( value...)</a></h3>
          
        
        
            
                <div class="parameter">
                  <h4>value</h4>
                  
                    <p>The values of the structure.</p>
                  
                </div>
            
        
        
          <p>Get the size of the structure for the given variable length values. A structure
can have 0 or more variable length values.</p>

<p>The <code>sizeOf</code> method does not expect and will not correctly calculate the size of
the structure if fixed size value are given.</p>
        
      
        
          <h3 class="class"><a name="Parser">packet.Parser()</a></h3>
        
        
            
        
        
          <p>Parses a buffer and emits events based on patterns.</p>
        
      
        
          
            <h3 class="function"><a name="packet_name_pattern_callback">packet(name, pattern,  [callback])</a></h3>
          
        
        
            
                <div class="parameter">
                  <h4>name</h4>
                  
                    <p>The name of the packet type.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>pattern</h4>
                  
                    <p>The packet pattern.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>callback</h4>
                  
                    <p>Called when a packet of this type has been read from a buffer.</p>
                  
                </div>
            
        
        
          <p>Defines a named packet type optionally assigning a default response for the
packet type.</p>
        
      
        
          
            <h3 class="function"><a name="parse_nameOrPattern">parse(nameOrPattern)</a></h3>
          
        
        
            
                <div class="parameter">
                  <h4>nameOrPattern</h4>
                  
                    <p>Either the name of a named packet or a one off </p>
                  
                </div>
            
        
        
          
        
      
        
          
            <h3 class="function"><a name="clone">clone()</a></h3>
          
        
        
            
        
        
          <p>Clone the packet parser to create a packet parser that shares the named packet
definitions but has its own parser state.</p>

<p>This allows a packet parser prototype to be used to efficently create initialized
instances.</p>
        
      
        
          <h3 class="class"><a name="Serializer">packet.Serializer()</a></h3>
        
        
            
        
        
          
        
      
    </div>
    <div id="api">
      
        
      
        
          <h2 class="heading"><a href="#Synopsis">Synopsis</a></h3>
        
      
        
          <h2 class="heading"><a href="#Objectives">Objectives</a></h3>
        
      
        
          <h2 class="heading"><a href="#Installing">Installing</a></h3>
        
      
        
          <h2 class="heading"><a href="#Binary Pattern Language">Binary Pattern Language</a></h3>
        
      
        
          <h2 class="heading"><a href="#Reference">Reference</a></h3>
        
      
        
          <h3 class="namespace depth-0"><a href="#packet">packet</a></h3>
        
      
        
          <h3 class="class depth-1"><a href="#Structure">Structure</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#read_buffer_offset_callback">read</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#write_buffer_offset_value">write</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#sizeOf_value">sizeOf</a></h3>
        
      
        
          <h3 class="class depth-1"><a href="#Parser">Parser</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#packet_name_pattern_callback">packet</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#parse_nameOrPattern">parse</a></h3>
        
      
        
          <h3 class="function depth-2"><a href="#clone">clone</a></h3>
        
      
        
          <h3 class="class depth-1"><a href="#Serializer">Serializer</a></h3>
        
      
      
        <h2 class="heading">Docco</h3>
        
          
        
          
            
            <h3 class="docco depth-0"><a href="./documentation/packet.html">packet.coffee</a></h3>
          
        
          
            
            <h3 class="docco depth-0"><a href="./documentation/pattern.html">pattern.coffee</a></h3>
          
        
          
            
            <h3 class="docco depth-0"><a href="./documentation/argument.html">argument.coffee</a></h3>
          
        
      
    </div>
  </div>
</body>
</html>
