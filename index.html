<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link href="http://fonts.googleapis.com/css?family=Questrial|Inder|Sonsie+One|Michroma|Atomic+Age|Russo+One|Source+Code+Pro|Numans|Montserrat|Aldrich|Electrolize|Krona+One|Quantico|Warnes|Prosto+One|Titillium+Web" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="css/packet.css">
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<title>Packet</title>
<body><div class="container">

<div class="unit welcome">
<h1>Packet</h1>
<p>An evented binary packet and structure parser for Node.js.
</p></div>

<div class="unit value-proposition markdown"><p>Packet creates <strong>pre-compiled</strong>, <strong>pure-JavaScript</strong>, <strong>binary parsers</strong> and
<strong>serializers</strong> that are <strong>incremental</strong> through a binary pattern language that
is <strong>declarative</strong> and very <strong>expressive</strong>.</p>
</div>

<div class="unit description"><p>Packet simplifies the construction an maintenance of libraries that convert
binary to JavaScript and back. The name Packet may make you think that it is
designed solely for binary network protocols, but it is also great for reading
and writing binary file formats.</p>
<p><strong>Incremental</strong> — Node packet creates incremental parsers and serializers
that are almost as fast as the parser you&#39;d write by hand, but a lot easier to
define and maintain.</p>
<p><strong>Declarative</strong> — Packet defines a binary structure using a pattern
language inspired by Perl&#39;s <code>pack</code>. The binary patterns are used to define both
parsers and serializers. If you have a protocol specification, or even just a C
header file with structures that define your binary data, you can probably
translate that directly into Packet patterns.</p>
<p>For parsers, you associate the patterns to callbacks invoked with captured
values when the pattern is extracted from the stream. For serializers you simply
give the values to write along with the pattern to follow when writing them.</p>
<p><strong>Expressive</strong> — The pattern language can express</p>
<ul>
<li>signed and unsigned integers,</li>
<li>endianess of singed and unsigned integers,</li>
<li>floats and doubles,</li>
<li>fixed length arrays of characters or numbers,</li>
<li>length encoded strings of characters or numbers,</li>
<li>zero terminated strings of characters or numbers,</li>
<li>said strings terminated any fixed length terminator you specify,</li>
<li>padding of said strings with any padding value you specify,</li>
<li>signed and unsigned integers extracted from bit packed integers,</li>
<li>conditions based on bit patterns</li>
<li>character encodings,</li>
<li>custom transformations,</li>
<li>and pipelines of character encodings and custom transformations.</li>
</ul>
<h3>Limitations</h3>
<p><strong>Parsing not searching</strong> — Packet is not a pattern matching library. It
does not search binary streams for patterns. Packet is used for parsing
well-defined streams of binary data.</p>
<p><strong>8-bit boundaries</strong> — I&#39;m unable to think of an example in contemporary
computing that doesn&#39;t align to an 8-bit boundary, but the world is big and I am
small, so I plan on being surprised. I can also imagine that someone might want
to unleash Packet on legacy data someday, from way back when a byte was whatever
a computer manufacturer said it was.</p>
<p>Therefore, It&#39;s worth noting that Packet parses 8-bit bytes and expects bytes to
align to an 8-bit boundary. Packet can parse 7-bit ASCII formats like <code>tar</code>
archives, because they are 8-bit aligned with the top bit ignored. Packet can
also parse and serialize bit packed integers, so it does support awkward integer
sizes, but within an 8-bit aligned integer.</p>
<h2>Installing</h2>
<p>Install Packet using NPM.</p>
<pre><code>npm install packet</code></pre>
<p>The source is available on <a href="https://github.com/bigeasy/packet">GitHub</a>.</p>
<h2>Parsers and Serializers</h2>
<p>Packet defines a binary format using a binary pattern language inspired by
Perl&#39;s <code>pack</code> function. The pattern language is used in a <code>Parser</code> to define the
parameters passed to callback when enough bytes are read from the input stream
to satisfy the pattern. The pattern language is used in a <code>Serializer</code> to define
how JavaScript primitives passed to the <code>serialize</code> method are written to
stream.</p>
<h3>Patterns</h3>
<p>Patterns are a series of element declarations joined by commas.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">parser</span><span class="p">.</span><span class="nx">extract</span><span class="p">(</span><span class="s2">&quot;length: b16, address: b32, name: b8z&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">object</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">object</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">([</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">]);</span>
</pre></div>
</code></pre>
<p>You can also name the elements in a pattern. If named, parsers will be create an
object to pass to callbacks, serializers will serialize an object&#39;s properties.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">parser</span><span class="p">.</span><span class="nx">extract</span><span class="p">(</span><span class="s2">&quot;b16 =&gt; length, b32 =&gt; address, b8z =&gt; name&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">record</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">([</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">]);</span>
</pre></div>
</code></pre>
<p>Unnamed elements are good for short, simple patterns. For longer patterns it is
easier to have a parser build an object for you.</p>
<p>The following example shows a complicated pattern, the invariable portion of an
IP header, the first 20 bytes before options, if any.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="c1">// Define an IP header pattern using a joined array to explode the pattern.</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="s1">&#39;ip&#39;</span><span class="p">,</span> <span class="s1">&#39;b8{version: b4, headerLength: b4},         \</span>
<span class="s1">                     typeOfService: b8,                         \</span>
<span class="s1">                     length: b16,                               \</span>
<span class="s1">                     identification: b16,                       \</span>
<span class="s1">                     b16{flags: b3, fragmentOffset: b13},       \</span>
<span class="s1">                     timeToLive: b8,                            \</span>
<span class="s1">                     protocol: b8,                              \</span>
<span class="s1">                     checksum: b16,                             \</span>
<span class="s1">                     sourceAddress: b32,                        \</span>
<span class="s1">                     destinationAddress: b32                    \</span>
<span class="s1">                    &#39;</span><span class="p">);</span>

<span class="c1">// The pattern is then used to defined parser and serializer actions.</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">extract</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">header</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Both parsers and serializers can define patterns using the <code>packet</code> method. The
<code>packet</code> method allows you to pre-compile patterns.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="c1">// Create a parser and define a header.</span>
<span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;packet&#39;</span><span class="p">).</span><span class="nx">createParser</span><span class="p">();</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="s2">&quot;b8 =&gt; type, b16 =&gt; length, b32 =&gt; extra&quot;</span><span class="p">);</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;b16 =&gt; sequence, b16 =&gt; crc&quot;</span><span class="p">);</span>

<span class="c1">// Now you can define your serializer using your parser as a prototype. The</span>
<span class="c1">// serializer will inherit the parser&#39;s packet definitions.</span>
<span class="kd">var</span> <span class="nx">serializer</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">createSerializer</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>Parsers and serializers maintain internal state so that they can be used
incrementally. If you&#39;re going to parse streams incrementally, you&#39;re going to
need a parser for each stream your parsing. Same goes for serializers and
serializing.</p>
<p>When parsing/serializing incrementally create new parsers and serializers using
the prototype pattern above.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="c1">// Create a serializer and define a header.</span>
<span class="kd">var</span> <span class="nx">serializer</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;packet&quot;</span><span class="p">).</span><span class="nx">createSerializer</span><span class="p">();</span>
<span class="nx">serializer</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="s2">&quot;b8 =&gt; type, b16 =&gt; length, b32 =&gt; extra&quot;</span><span class="p">);</span>
<span class="nx">serializer</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;b16 =&gt; sequence, b16 =&gt; crc&quot;</span><span class="p">);</span>

<span class="c1">// Now you can define parsers for a using the serializer as a prototype.</span>
<span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">socket</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">serializer</span><span class="p">.</span><span class="nx">createParser</span><span class="p">();</span>
  <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parser</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nx">parser</span><span class="p">.</span><span class="nx">extract</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">header</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<h3>Parsers</h3>
<p>Parsers parse a buffer extracting a specified pattern. The pattern is specified
using the <code>extract</code> method. The <code>extract</code> method accept either a pattern or the
name a pre-compiled pattern.</p>
<p>After the pattern has been specified, the parser will extract the data from one
or more buffers according to the specified pattern.</p>
<p>When the pattern specified by <code>extract</code> has been read from the series of
buffers, it will invoke a callback with the extracted values. The <code>extract</code>
callback has the option of calling the <code>extract</code> method specifying a subsequent
pattern for the parser to extract. When the callback returns, the parser will
immediately continue to parse the newly specified pattern from the series of
buffers.</p>
<p>The parser callback receives the values either as positioned function arguments
or as an object. How the callback is invoked is based on the pattern and the
<a href="http://en.wikipedia.org/wiki/Arity">arity</a> of the callback function.</p>
<p>To receive an object in the callback, we defined named elements. When the
pattern has at least one named element, and the callback has only a single
argument, an object is passed to the callback containing the values using the
element names as keys.</p>
<p>Unnamed elements are excluded, but there&#39;s no good reason not name them. Use a
skip pattern to skip over unwanted bytes instead.</p>
<p>You can still get positioned arguments using a named pattern. Just provide a
callback with more than one argument and it will be invoked with the extract
values as parameters.</p>
<p>A callback for a pattern without any named elements is always invoked with
values as parameters regardless of arity.</p>
<h3>Serializers</h3>
<p>First you call <code>serialize</code> with a pattern and arguments to serialize, then you
call <code>write</code> with a series of buffers.</p>
</div>
<div class="unit description"><h2>Error Messages</h2>
<p>Error messages for pattern parsing.</p>
<ul>
<li><strong>invalid pattern at N</strong> — The characters starting at the specified
index is unexpected the pattern is invalid. The invalid character may not be
at the specified index, but shortly there after, such as unmatched braces.</li>
<li><strong>bit field overflow at N</strong> — The sum of the bit size of bit field
elements is greater than the size of the containing element. The sum of the
bit size of bit field elements must equal the size of the containing element.</li>
<li><strong>bit field underflow at N</strong> — The sum of the bit size of bit field
elements is less than the size of the containing element. The sum of the bit
size of bit field elements must equal the size of the containing element.</li>
<li><strong>bit size must be non-zero at N</strong> — Encountered element with a bit size of
zero. Element size must be a non-zero value.</li>
<li><strong>bits must be divisible by 8 at N</strong> — Encountered element with a bit
size that is not divisible by 8. If an element is not a bit field element, it
must align to an 8-bit boundary.</li>
<li><strong>floats can only be 32 or 64 bits at N</strong> — Encountered a float element
with an unsupported bit size. Only 32 and 64 bit floats are supported.</li>
<li><strong>&quot;array length must be non-zero at N</strong> — Encountered an array length
of zero. Arrays must have a non-zero length.</li>
</ul>
<h2>Contributors</h2>
<ul>
<li><a href="https://github.com/neonstalwart">Ben Hockey</a></li>
<li><a href="https://github.com/aq1018">Aaron Qian</a></li>
</ul>
</div>

</div></body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-20388260-3', 'bigeasy.github.io');
  ga('send', 'pageview');
</script>
</html>
