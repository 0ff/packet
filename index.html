<!DOCTYPE html>
<html>
<title>Packet</title>
<body><div class="container">

<div class="unit description"><p>An evented binary packet and structure parser for Node.js.</p>
<h2>Contributors</h2>
<ul>
<li><a href="https://github.com/neonstalwart">Ben Hockey</a></li>
<li><a href="https://github.com/aq1018">Aaron Qian</a></li>
</ul>
<h2>Objectives</h2>
<p>Packet creates <strong>binary parsers</strong> and <strong>serializers</strong> that are <strong>incremental</strong>
through a binary pattern language that is <strong>declarative</strong> and very
<strong>expressive</strong>.</p>
<p>Packet simplifies the construction an maintenance of libraries that convert
binary to JavaScript and back. The name Packet may make you think that it is
designed solely for binary network protocols, but it is also great for reading
and writing binary file formats.</p>
<p><strong>Incremental</strong> — Node packet creates incremental parsers and serializers
that are almost as fast as the parser you&#39;d write by hand, but a lot easier to
define and maintain.</p>
<p><strong>Declarative</strong> — Packet defines a binary structure using a pattern
language inspired by Perl&#39;s <code>pack</code>. The binary patterns are used to define both
parsers and serializers. If you have a protocol specification, or even just a C
header file with structures that define your binary data, you can probably
translate that directly into Packet patterns.</p>
<p>For parsers, you associate the patterns to callbacks invoked with captured
values when the pattern is extracted from the stream. For serializers you simply
give the values to write along with the pattern to follow when writing them.</p>
<p><strong>Expressive</strong> — The pattern language can express</p>
<ul>
<li>signed and unsigned integers,</li>
<li>endianess of singed and unsigned integers,</li>
<li>floats and doubles,</li>
<li>fixed length arrays of characters or numbers,</li>
<li>length encoded strings of characters or numbers,</li>
<li>zero terminated strings of characters or numbers,</li>
<li>said strings terminated any fixed length terminator you specify,</li>
<li>padding of said strings with any padding value you specify,</li>
<li>signed and unsigned integers extracted from bit packed integers,</li>
<li>conditions based on bit patterns</li>
<li>character encodings,</li>
<li>custom transformations,</li>
<li>and pipelines of character encodings and custom transformations.</li>
</ul>
<h3>Limitations</h3>
<p><strong>Parsing not searching</strong> — Packet is not a pattern matching library. It
does not search binary streams for patterns. Packet is used for parsing
well-defined streams of binary data.</p>
<p><strong>8-bit boundaries</strong> — I&#39;m unable to think of an example in contemporary
computing that doesn&#39;t align to an 8-bit boundary, but the world is big and I am
small, so I plan on being surprised. I can also imagine that someone might want
to unleash Packet on legacy data someday, from way back when a byte was whatever
a computer manufacturer said it was.</p>
<p>Therefore, It&#39;s worth noting that Packet parses 8-bit bytes and expects bytes to
align to an 8-bit boundary. Packet can parse 7-bit ASCII formats like <code>tar</code>
archives, because they are 8-bit aligned with the top bit ignored. Packet can
also parse and serialize bit packed integers, so it does support awkward integer
sizes, but within an 8-bit aligned integer.</p>
<h2>Installing</h2>
<p>Install Packet using NPM.</p>
<pre><code>npm install packet</code></pre>
<p>The source is available on <a href="https://github.com/bigeasy/packet">GitHub</a>.</p>
<h2>Parsers and Serializers</h2>
<p>Packet defines a binary format using a binary pattern language inspired by
Perl&#39;s <code>pack</code> function. The pattern language is used in a <code>Parser</code> to define the
parameters passed to callback when enough bytes are read from the input stream
to satisfy the pattern. The pattern language is used in a <code>Serializer</code> to define
how JavaScript primitives passed to the <code>serialize</code> method are written to
stream.</p>
<h3>Patterns</h3>
<p>Patterns are a series of element declarations joined by commas.</p>
<pre><code class="lang-javascript">parser.extract(&quot;length: b16, address: b32, name: b8z&quot;, function (object) {
  console.log(object.length, object.address, object.name);
});
parser.parse([ 0x01, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00 ]);</code></pre>
<p>You can also name the elements in a pattern. If named, parsers will be create an
object to pass to callbacks, serializers will serialize an object&#39;s properties.</p>
<pre><code class="lang-javascript">parser.extract(&quot;b16 =&gt; length, b32 =&gt; address, b8z =&gt; name&quot;, function (record) {
  console.log(record);
});
parser.parse([ 0x01, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00 ]);</code></pre>
<p>Unnamed elements are good for short, simple patterns. For longer patterns it is
easier to have a parser build an object for you.</p>
<p>The following example shows a complicated pattern, the invariable portion of an
IP header, the first 20 bytes before options, if any.</p>
<pre><code class="lang-javascript">// Define an IP header pattern using a joined array to explode the pattern.
parser.packet(&#39;ip&#39;, &#39;b8{version: b4, headerLength: b4},         \
                     typeOfService: b8,                         \
                     length: b16,                               \
                     identification: b16,                       \
                     b16{flags: b3, fragmentOffset: b13},       \
                     timeToLive: b8,                            \
                     protocol: b8,                              \
                     checksum: b16,                             \
                     sourceAddress: b32,                        \
                     destinationAddress: b32                    \
                    &#39;);

// The pattern is then used to defined parser and serializer actions.
parser.extract(&quot;ip&quot;, function (header) {
  console.log(header);
});
parser.parse(buffer);</code></pre>
<p>Both parsers and serializers can define patterns using the <code>packet</code> method. The
<code>packet</code> method allows you to pre-compile patterns.</p>
<pre><code class="lang-javascript">// Create a parser and define a header.
var parser = require(&#39;packet&#39;).createParser();
parser.packet(&quot;header&quot;, &quot;b8 =&gt; type, b16 =&gt; length, b32 =&gt; extra&quot;);
parser.packet(&quot;data&quot;, &quot;b16 =&gt; sequence, b16 =&gt; crc&quot;);

// Now you can define your serializer using your parser as a prototype. The
// serializer will inherit the parser&#39;s packet definitions.
var serializer = parser.createSerializer();</code></pre>
<p>Parsers and serializers maintain internal state so that they can be used
incrementally. If you&#39;re going to parse streams incrementally, you&#39;re going to
need a parser for each stream your parsing. Same goes for serializers and
serializing.</p>
<p>When parsing/serializing incrementally create new parsers and serializers using
the prototype pattern above.</p>
<pre><code class="lang-javascript">// Create a serializer and define a header.
var serializer = require(&quot;packet&quot;).createSerializer();
serializer.packet(&quot;header&quot;, &quot;b8 =&gt; type, b16 =&gt; length, b32 =&gt; extra&quot;);
serializer.packet(&quot;data&quot;, &quot;b16 =&gt; sequence, b16 =&gt; crc&quot;);

// Now you can define parsers for a using the serializer as a prototype.
net.createServer(function (socket) {
  var parser = serializer.createParser();
  socket.on(&quot;data&quot;, function (buffer) {
    parser.parse(buffer);
  });
  parser.extract(&quot;header&quot;, function (header) {
    console.log(header);
  });
});</code></pre>
<h3>Parsers</h3>
<p>Parsers parse a buffer extracting a specified pattern. The pattern is specified
using the <code>extract</code> method. The <code>extract</code> method accept either a pattern or the
name a pre-compiled pattern.</p>
<p>After the pattern has been specified, the parser will extract the data from one
or more buffers according to the specified pattern.</p>
<p>When the pattern specified by <code>extract</code> has been read from the series of
buffers, it will invoke a callback with the extracted values. The <code>extract</code>
callback has the option of calling the <code>extract</code> method specifying a subsequent
pattern for the parser to extract. When the callback returns, the parser will
immediately continue to parse the newly specified pattern from the series of
buffers.</p>
<p>The parser callback receives the values either as positioned function arguments
or as an object. How the callback is invoked is based on the pattern and the
<a href="http://en.wikipedia.org/wiki/Arity">arity</a> of the callback function.</p>
<p>To receive an object in the callback, we defined named elements. When the
pattern has at least one named element, and the callback has only a single
argument, an object is passed to the callback containing the values using the
element names as keys.</p>
<p>Unnamed elements are excluded, but there&#39;s no good reason not name them. Use a
skip pattern to skip over unwanted bytes instead.</p>
<p>You can still get positioned arguments using a named pattern. Just provide a
callback with more than one argument and it will be invoked with the extract
values as parameters.</p>
<p>A callback for a pattern without any named elements is always invoked with
values as parameters regardless of arity.</p>
<h3>Serializers</h3>
<p>First you call <code>serialize</code> with a pattern and arguments to serialize, then you
call <code>write</code> with a series of buffers.</p>
</div>

</div></body>
</html>
