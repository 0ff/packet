
<!DOCTYPE html>
<html>
<head>
  <title>Node Packet</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="site/idl.css">
</head>
<body>
  
  <a href="http://github.com/bigeasy/node-packet"><img style="position: fixed; top: 0; right:
  0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"
  alt="Fork me on GitHub" /></a>
  
  <div id="container">
    <div id="narrative">
      
        
        
        
          <h1>Node Packet</h1>

<p>An evented binary packet and structure parser for Node.js.</p>
        
      
        
        
        
          <h2>Synopsis</h2>

<p>Use tar as an example?</p>
        
      
        
        
        
          <h2>Installing</h2>
        
      
        
        
        
          <h2>Rationale</h2>

<p>Node Packet aspires to be the go to library for converting binary data into
JavaScript or CoffeeScript primitives.</p>

<p>The following rationale is offered for the following questions that may or may
not be asked frequenty.</p>

<h3>Why didn't you derive from EventEmitter?</h3>

<p>EventEmitter is well suited for classes that have a set of API defined event
types. It does not at all suited for classes that emit of any number of event
types defined by the API user.</p>
        
      
        
        
        
          <h2>Bit Pattern Language</h2>

<h3>Big-Endian Byte Ordering</h3>

<p>To define a big-endian byte ordering for a field, prefix the bit size with <code>b</code>.
<strong>Mnemonic</strong>: The letter <code>b</code> stands for big-endian.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b16&quot;</span>             <span class="c1">// Big-endian 32 bit number.</span>
<span class="s2">&quot;b8&quot;</span>              <span class="c1">// Endianess of a single byte is irrelevant.</span>
<span class="s2">&quot;l16, b8&quot;</span>         <span class="c1">// Big-endian 16 bit integer followed by a byte.</span>
</pre></div>

        
          <h3>Little-Endian Byte Ordering</h3>

<p>To define a little-endian byte ordering for a field, prefix the bit size with <code>l</code>.
<strong>Mnemonic</strong>: The letter <code>l</code> stands for little-endian.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l32&quot;</span>             <span class="c1">// Little-endian 32 bit integer.</span>
<span class="s2">&quot;l8&quot;</span>              <span class="c1">// Endianess of a single byte is irrelevant.</span>
<span class="s2">&quot;l16, b8&quot;</span>         <span class="c1">// Little endian 16 bit integer followed by a byte.</span>
</pre></div>

        
          <h3>Skipping Bytes</h3>

<p>You can skip over bytes your pattern with <code>x</code>. <strong>Mnemonic</strong>: The letter <code>x</code>
means to cross-out, which is kind of like skipping.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b8, x16, l16&quot;</span>    <span class="c1">// A byte separated from a little-endian 16 bit integer by 16</span>
                  <span class="c1">// two bytes.</span>
</pre></div>

        
          <h3>Signed Versus Unsigned Integers</h3>

<p>All numbers are assumed to be unsigned, unless prefixed by a negative symbol.
<strong>Mnemonic</strong>: The <code>-</code> symbol indicates the possiblity of negative numbers.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;-b32&quot;</span>            <span class="c1">// Big-endian 32 bit signed integer.</span>
<span class="s2">&quot;-l32&quot;</span>            <span class="c1">// Little-endian 32 bit signed integer.</span>
<span class="s2">&quot;b32&quot;</span>             <span class="c1">// Big-endian 32 bit unsigned integer.</span>
</pre></div>

        
          <h3>IEEE 754 Floating Point Numbers</h3>

<p>The number type for JavaScript is the  64 bit IEEE 754 floating point. Node
Packet can read write 64 bit and 32 bit IEEE 754 floating point numbers.</p>

<p>To indicated that the type is a floating point number, use the <code>f</code> type suffix.
This is indicated with a <code>f</code> suffix.  <strong>Mnemonic</strong>: The letter <code>f</code> stands for
<em>floating-point</em>.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b64f&quot;</span>            <span class="c1">// Big-endian 64 bit IEEE 754 double floating point number.</span>
<span class="s2">&quot;l32f&quot;</span>            <span class="c1">// Little-endian 32 bit IEEE 754 single floating point number.</span>
</pre></div>

        
          <p>The floating-point numbers can be stored in little-endian or big-endian byte order.</p>

<h3>Arrays of Raw Bytes</h3>

<p>A value will be converted to a big-endian array of bytes if followed by an <code>a</code>
suffix. <strong>Mnemonic</strong>: The letter <code>a</code> stands for <em>array</em>.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128a&quot;</span>           <span class="c1">// Unsigned little-endian 128 bit integer as big-endian array</span>
                  <span class="c1">// of bytes.</span>
</pre></div>

        
          <p>Note that big-endian means that the most signifcant byte is at index <code>0</code> of the
array.</p>

<p>This can be surprising if you're expecting the the significance of the bytes
will increase with the index of the array, but then that's what little-endian is
all about. (Big-endian orders like Arabic numerals, while little-endian orders
like offsets into memory.)</p>

<p>If you'd prefer a little-endian array, you can reverse the array with the <code>@</code>
qualifier. <strong>Mnemonic</strong>: The <code>@</code> character is a swirl and we want to turn our
array around.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128a@&quot;</span>          <span class="c1">// Unsigned little-endian 128 bit integer as little-endian</span>
                  <span class="c1">// array of bytes.</span>
</pre></div>

        
          <h3>Bytes as Hex Strings</h3>

<p>A value will be converted to a big-endian hex string if followed by an <code>h</code>
suffix. </p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128h&quot;</span>           <span class="c1">// Unsigned little-endian 128 bit integer as a big-endian hex</span>
                  <span class="c1">// string.</span>
</pre></div>

        
          <p>Like the raw byte of arrays, the hex string is in big-endian order with the most 
significant bytes at the top. It is less likely that you'll want to reverse a
hex string, but if you, you can use the <code>@</code> qualifier. <strong>Mnemonic</strong>: The <code>@</code>
character is a swirl and we want to turn our string  around.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l128h@&quot;</span>          <span class="c1">// Unsigned little-endian 128 bit integer as a little-endian</span>
                  <span class="c1">// hex string.</span>
</pre></div>

        
          <h3>Arrays of Common Types</h3>

<p>It is often the case that a binary format contains an array of values. The most
common case are arrays of bytes represnting ASCII or UTF-8 strings.</p>

<p>Arrays are specified with an subscript and a count. <strong>Menmonic</strong>: The square
brackets are used as array subscripts in JavaScript, and used to declare array
length in other C dialect languages.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b32[4]&quot;</span>          <span class="c1">// An array of four big-endian 32 bit numbers.</span>
<span class="s2">&quot;b8[16]&quot;</span>          <span class="c1">// An array of 16 bytes.</span>
</pre></div>

        
          <p>The array notation produces an array of the type before the subscript.</p>

<h3>Length Encoded Arrays</h3>

<p>Length encoded arrays are specified by joining a count type and a value type
with a <code>/</code>. <strong>Mnemonic</strong>: Inspired by Perl's <code>pack</code>, this count and type
separator character is as good as any.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;b8/b8&quot;</span>           <span class="c1">// Length encoded byte array with a byte length.</span>
<span class="s2">&quot;l16/b8&quot;</span>          <span class="c1">// Length encoded byte array with 16 bit little-endian length.</span>
</pre></div>

        
          <h3>Zero Terminated Arrays</h3>

<p>Zero terminated series are speified with a <code>z</code> qualifier. <strong>Mnemonic</strong>: The
letter <code>z</code> stands for zero.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;l16z&quot;</span>            <span class="c1">// Little-endian 16 bit numbers terminated by a zero value.</span>
<span class="s2">&quot;b8z&quot;</span>             <span class="c1">// Byte string terminated by zero.</span>
</pre></div>

        
          <h3>Transforms</h3>

<p>Often there are transformations that you need to perform on an field to get
it to its final state. You may need to convert a byte array to string of a
particular character encoding, for example. This is done with a tranformation
functions which are specified with a transformation pipeline.</p>

<p>If the transformation is a fixed transformation, you can perform the
transformation by defining a pipeline. A pipeline defines one or more
tranformations that are invoked on the value after parsing and before
serialization. The transformations can accept scalar JavaScript parameters.</p>
        
          <div class="highlight"><pre><span class="kd">function</span> <span class="nx">str</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">parsing</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">parsing</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">buffer</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">length</span> <span class="o">+=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">reutrn</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">value</span> <span class="o">+=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">terminator</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

        
          <p>Now you can use the transform in your pattern.</p>
        
          <div class="highlight"><pre><span class="s2">&quot;n8z|str(&#39;ascii&#39;)&quot;</span>      <span class="c1">// An ascii string terminated by zero.</span>
<span class="s2">&quot;n8z|str(&#39;ascii&#39;), b16&quot;</span> <span class="c1">// An ascii string terminated by zero followed by a</span>
                        <span class="c1">// big-endian 16 bit integer.</span>
</pre></div>

        
          <p>The <code>str</code> transform is defined by default. The transform names are purposely
terse to fit with the brevity of the pattern language.</p>
        
      
        
        
        
          <h2>Reference</h2>
        
      
        
          <h3 class="namespace">packet</h3>
        
        
        
          <p>Node Packet exports the ec2 namespace, which provides the {{Structure}},
{{Parser}} and {{Serializer}} classes.</p>
        
      
        
          <h3 class="class">packet.Structure(pattern)</h3>
        
        
            
                <div class="parameter">
                  <h4>pattern</h4>
                  
                    <p>The packet pattern.</p>
                  
                </div>
            
        
        
          <p>A structure is an object that both reads from and writes to a buffer
syncrhonously. When reading, buffer must contain the entire contents of the
structure. When writing, the buffer must have enough space to accomdoate the
structure.</p>
        
      
        
          
            <h3 class="function">read(buffer,  [offset], callback)</h3>
          
        
        
            
                <div class="parameter">
                  <h4>buffer</h4>
                  
                    <p>The byte buffer.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>offset</h4>
                  
                    <p>The optional offset into the byte buffer. Defaults to <code>0</code>.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>callback</h4>
                  
                    <p>Called with the parameters read from the byte buffer.</p>
                  
                </div>
            
        
        
          <p>The read method accepts a buffer with an optional offset. The number of
arguments is determined by the structure packet pattern, and must match
the number of arguments expected by the packet pattern.</p>

<p>The callback will be called with the fields read from the buffer, with the
actual count of bytes read as the last parameter.</p>
        
      
        
          
            <h3 class="function">write(buffer)</h3>
          
        
        
            
                <div class="parameter">
                  <h4>buffer</h4>
                  
                    <p>The byte buffer.</p>
                  
                </div>
            
        
        
          <p>Write the arguments to the  buffer at the optional offset. The arguments are
determined by the structure bit pattern. Returns the number of bytes written.</p>
        
      
        
          
            <h3 class="function">sizeOf()</h3>
          
        
        
            
        
        
          <p>Get the size of the structure for the given variable length values. A structure
can have 0 or more variable length values.</p>

<p>The <code>sizeOf</code> method does not expect and will not correctly calculate the size of
the structure if fixed size value are given.</p>
        
      
        
          <h3 class="class">packet.Parser()</h3>
        
        
            
        
        
          
        
      
        
          
            <h3 class="function">packet(name, pattern,  [callback])</h3>
          
        
        
            
                <div class="parameter">
                  <h4>name</h4>
                  
                    <p>The name of the packet type.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>pattern</h4>
                  
                    <p>The packet pattern.</p>
                  
                </div>
            
                <div class="parameter">
                  <h4>callback</h4>
                  
                    <p>Called when a packet of this type has been read from a buffer.</p>
                  
                </div>
            
        
        
          <p>Defines a named packet type optionally assigning a default response for the
packet type.</p>
        
      
        
          
            <h3 class="function">parse(nameOrPattern)</h3>
          
        
        
            
                <div class="parameter">
                  <h4>nameOrPattern</h4>
                  
                    <p>Either the name of a named packet or a one off </p>
                  
                </div>
            
        
        
          
        
      
        
          
            <h3 class="function">clone()</h3>
          
        
        
            
        
        
          <p>Clone the packet parser to create a packet parser that shares the named packet
definitions but has its own parser state.</p>

<p>This allows a packet parser prototype to be used to efficently create initialized
instances.</p>
        
      
        
          <h3 class="class">packet.Serializer()</h3>
        
        
            
        
        
          
        
      
    </div>
    <div id="api">
      
        
      
        
          <h2 class="heading">Synopsis</h3>
        
      
        
          <h2 class="heading">Installing</h3>
        
      
        
          <h2 class="heading">Rationale</h3>
        
      
        
          <h2 class="heading">Bit Pattern Language</h3>
        
      
        
          <h2 class="heading">Reference</h3>
        
      
        
          <h3 class="namespace depth-0">packet</h3>
        
      
        
          <h3 class="class depth-1">Structure</h3>
        
      
        
          <h3 class="function depth-2">read</h3>
        
      
        
          <h3 class="function depth-2">write</h3>
        
      
        
          <h3 class="function depth-2">sizeOf</h3>
        
      
        
          <h3 class="class depth-1">Parser</h3>
        
      
        
          <h3 class="function depth-2">packet</h3>
        
      
        
          <h3 class="function depth-2">parse</h3>
        
      
        
          <h3 class="function depth-2">clone</h3>
        
      
        
          <h3 class="class depth-1">Serializer</h3>
        
      
      
        <h2 class="heading">Docco</h3>
        
          
        
          
            
            <h3 class="docco depth-0"><a href="./documentation/packet.html">packet.coffee</a></h3>
          
        
          
            
            <h3 class="docco depth-0"><a href="./documentation/pattern.html">pattern.coffee</a></h3>
          
        
      
    </div>
  </div>
</body>
</html>
